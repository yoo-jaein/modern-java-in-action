# Chapter 07 병렬 데이터 처리와 성능

## 병렬 스트림
- parallelStream을 호출하면 병렬 스트림(parallel stream)이 생성된다.
- 병렬 스트림이란 각각의 스레드에서 처리할 수 있도록 스트림 요소를 여러 청크로 분할한 스트림이다.
- 병렬 스트림을 이용하면 모든 멀티코어 프로세스가 각각의 청크를 처리하도록 할당할 수 있다.
- 처리해야 할 데이터가 아주 많거나 각 요소를 처리하는 데 오랜 시간이 걸릴 때 성능을 높일 수 있다.

## 레이스 컨디션
레이스 컨디션(race condition), 경쟁 상태란 공유 자원에 대해 여러 프로세스가 동시에 접근을 시도할 때 접근 타이밍이나 순서 등이 결과값에 영향을 줄 수 있는 상태다. 레이스 컨디션이 발생하면 자료의 일관성을 해칠 수도 있다.

## JMH로 스트림 성능 측정하기
- Java Microbenchmark Harness(JMH)
- 항상 병렬 처리가 빠른 것은 아니다. 병렬 처리를 사용했을 때 성능을 직접 측정해봐야 한다.

## 병렬 스트림 효과적으로 사용하기
1. 무조건 병렬 스트림이 순차 스트림보다 빠른 것은 아니다.
2. 박싱을 주의하라. 자동 박싱/언박싱은 성능을 크게 저하시킬 수 있는 요소다.
3. 순차 스트림보다 병렬 스트림에서 성능이 떨어지는 연산이 있다.
4. 소량의 데이터에서는 병렬 스트림이 도움 되지 않는다.
5. 스트림을 구성하는 자료구조가 적절한지 확인하자.
6. 중간 연산에 따라 성능이 달라질 수 있다.
7. 최종 연산의 병합 과정이 비쌀 수 있다.

## 포크/조인 프레임워크
- 자바 7은 포크/조인 프레임워크 기능을 제공한다. 포크/조인 프레임워크는 병렬화할 수 있는 작업을 재귀적으로 작은 작업으로 분할한 다음에 서브태스크 각각의 결과를 합쳐서 전체 결과를 만들도록 설계되었다.
- 포크/조인 프레임워크는 사용 가능한 모든 프로세서 코어를 활용하여 병렬 처리 속도를 높이는 데 도움이 되는 도구를 제공한다.
- 효과적인 병렬 실행을 제공하기 위해 ForkJoinWorkerThread 타입의 워커 스레드를 관리하는 ForkJoinPool이라는 스레드 풀을 사용합니다.

### ForkJoinPool
- ForkJoinPool은 프레임워크의 핵심이다. 워커 스레드를 관리하고 스레드 풀 상태 및 성능에 대한 정보를 얻을 수 있는 도구를 제공하는 ExecutorService의 구현체다.
- 워커 스레드는 한 번에 하나의 작업만 실행할 수 있다.
- 각 스레드는 작업을 저장하는 양방향 큐(또는 데크)가 있다.

### RecursiveTask의 compute()
compute 메서드는 다음의 의사코드 형식을 가진다.

```text
if (태스크가 충분히 작거나 더 이상 분할할 수 없으면) {
    1. 순차적으로 태스크 계산
} else {
    1. 태스크를 두 서브태스크로 분할
    2. 태스크가 다시 서브태스크로 분할되도록 이 메서드를 재귀 호출함
    3. 모든 서브태스크의 연산이 완료될 때까지 기다림
    4. 각 서브태스크의 결과를 합침
}
```

- 분할 후 정복(divide-and-conquer) 알고리즘의 병렬화 버전이다.
- 병렬화할 수 있는 태스크를 작은 태스크로 분할한다. 그 다음, 분할된 태스크를 각각의 스레드로 실행한다. 마지막으로 서브태스크 각각의 결과를 합쳐서 최종 결과를 생산한다.

### 코어 개수와 서브태스크의 개수
- 일반적으로 하드웨어의 코어 개수에 비해 서브태스크의 개수는 훨씬 많다. 대부분의 기기에는 코어가 네 개뿐이므로 천 개 이상의 서브태스크는 자원만 낭비하는 것 같아 보일 수 있다. 하지만 실제로는 코어 개수와 관계없이 적절한 크기로 분할된 많은 태스크를 포킹하는 것이 바람직하다.  

### 작업 훔치기
- 작업 훔치기(work stealing) 기법은 ForkJoinPool의 모든 스레드를 거의 공정하게 분할한다.
- 아무 일도 하지 않는 스레드는 바쁜 스레드의 데크에서 작업을 훔치려고 시도한다.
- 각각의 스레드는 작업이 끝날 때마다 자신에게 할당된 태스크를 포함하는 더블 링크드 리스트의 헤드를 참조하면서 다음 작업을 처리한다. 이때 한 스레드는 다른 스레드보다 자신에게 할당된 태스크를 더 빨리 처리할 수도 있다. 할일이 없어진 스레드는 유휴 상태(idle)로 바뀌는 것이 아니라 다른 스레드 큐의 꼬리에서 작업을 훔쳐온다. 모든 스레드의 큐가 빌 때까지 이 과정이 반복된다. 따라서 태스크의 크기를 작게 나누어야 작업자 스레드 간의 작업부하를 비슷한 수준으로 유지할 수 있다.
- 작업 훔치기 기법을 통해 스레드가 작업을 위해 경쟁할 가능성을 최소화한다. 또한, 사용 가능한 가장 큰 작업 덩어리에서 먼저 작업하기 때문에 스레드가 작업을 찾아야 하는 횟수도 줄어듭니다.

## 참고
https://www.baeldung.com/java-fork-join  
https://hamait.tistory.com/612  
