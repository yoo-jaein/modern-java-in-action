# Chapter 13 디폴트 메서드

## 디폴트 메서드의 등장
인터페이스를 구현하는 클래스는 인터페이스에서 정의하는 모든 메서드를 구현해야 한다. 평소에는 이 규칙을 지키는 데 아무 문제가 없지만 라이브러리 설계자 입장에서 인터페이스를 바꾸고 싶을 때 문제가 발생한다. 자바 8 API에도 List 인터페이스에 sort 같은 메서드가 추가되면서 문제가 발생한다.  

컬렉션 프레임워크 Guava, Apache Common 등 기존의 List 인터페이스를 구현했던 모든 프로그래머가 새로운 sort 메서드를 구현하도록 고쳐야 한다면 얼마나 당황스러울까? 자바 8에서는 이 문제를 해결하는 새로운 기능으로 정적 메서드(static method)와 디폴트 메서드(default method) 기능을 제공한다. 라이브러리 설계자라면 기존 구현을 고치지 않고도 인터페이스를 바꿀 수 있기 때문에 디폴트 메서드를 잘 이해하는 것이 중요하다. 또한 디폴트 메서드는 다중 상속 동작이라는 유연성을 제공하면서 프로그램 구성에도 도움을 준다.

## 디폴트 메서드란?
```java
public interface Sized {
	int size(); // 추상 메서드
	default boolean isEmpty() { // 디폴트 메서드
		return size() == 0;
	}
}
```

- 디폴트 메서드는 인터페이스의 메서드 기본 구현을 제공한다.
- 디폴트 메서드는 default 키워드로 시작하며 메서드 바디를 포함한다.
- 기존 인터페이스를 구현하는 클래스는 자동으로 디폴트 메서드를 상속받게 된다.
- 디폴트 메서드를 통해 기존의 코드 구현을 고칠 필요 없이 인터페이스만 바꿀 수 있다.

## 추상 클래스와 자바 8 인터페이스 비교
### 공통점
- 추상 클래스와 인터페이스 모두 추상 메서드와 바디를 포함하는 메서드를 정의할 수 있다.

### 차이점
- 클래스는 하나의 추상 클래스만 상속받을 수 있지만 인터페이스를 여러 개 구현할 수 있다.
- 추상 클래스는 인스턴스 변수(필드)를 가질 수 있지만 인터페이스는 인스턴스 변수를 가질 수 없다.

## 자바 8 API의 디폴트 메서드 활용
- Collection.stream() 
- List.sort() 
- Predicate.end(), Function.andThen() 등 함수형 인터페이스의 다양한 디폴트 메서드
  - 함수형 인터페이스는 오직 하나의 추상 메서드를 포함한다. 디폴트 메서드는 추상 메서드에 해당하지 않는다.

## 활용 예제

### 인터페이스 조립, 코드 재사용
디폴트 메서드 덕분에 이제 클래스는 여러 인터페이스에서 동작(구현 코드)을 상속받을 수 있다. 따라서 중복되지 않는 최소한의 인터페이스를 유지한다면 인터페이스를 조합해서 필요한 다양한 클래스를 구현할 수 있다. 자동으로 디폴트 메서드 코드를 재사용할 수 있기 때문이다. 다만 상속으로 코드 재사용 문제를 모두 해결할 수 있는 것은 아니다. 예를 들어 한 개의 메서드를 재사용하려고 거대한 클래스를 상속받는 것은 좋은 생각이 아니다. 이럴 때는 델리게이션(delegation), 멤버 변수를 이용해서 클래스에서 필요한 메서드를 직접 호출하는 메서드를 작성하는 것이 좋다.

### 다중 상속 동작
같은 시그니처를 갖는 디폴트 메서드를 상속받는 상황이 생길 수 있다. 다른 클래스나 인터페이스로부터 같은 시그니처를 갖는 메서드를 상속받을 때는 다음 세 가지 규칙을 따라야 한다.
1. 클래스가 항상 이긴다. 클래스에서 정의한 메서드가 디폴트 메서드보다 우선권을 갖는다.
2. 1번 외에는 서브인터페이스가 이긴다. B가 A를 상속받고 두 인터페이스에서 동일한 시그니처의 메서드가 정의되어 있다면 B가 이긴다.
3. 여전히 우선순위가 결정되지 않았다면 여러 인터페이스를 상속받는 클래스에서 명시적으로 디폴트 메서드를 오버라이드하고 선택해야 한다. 그렇지 않으면 "Error: class X inherits unrelated defaults for x() from types Y and Z."같은 컴파일 에러가 발생한다.
