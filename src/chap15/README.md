# Chapter 15 CompletableFuture와 리액티브 프로그래밍 컨셉의 시초

## 매시업 애플리케이션
요즘에는 독립적으로만 동작하는 웹사이트나 애플리케이션을 찾아보기 힘들다. 앞으로의 애플리케이션은 다양한 소스의 콘텐츠를 합치고 가공하는 매시업(mashup) 형태가 될 가능성이 크다. 이런 애플리케이션을 구현하려면 다양한 서비스에 접근해야 한다. 하지만 이들 서비스의 응답을 기다리는 동안 연산이 블록되거나 CPU 클록 사이클 자원을 낭비하고 싶진 않다. 예를 들어 페이스북의 데이터를 기다리는 동안 트위터 데이터를 처리하지 말라는 법은 없다. 애플리케이션의 생산성을 극대화할 수 있도록 코어를 바쁘게 유지하기 위해 자바에서는 여러 도구를 제공한다. 

## 동시성 vs 병렬성
동시성은 단일 코어 머신에서 발생할 수 있는 프로그래밍 속성이다. 실행이 서로 겹칠 수 있다.
병렬성은 병렬 실행을 하드웨어 수준에서 제공한다.

## 자바의 동시 프로그래밍
1. 처음에는 Runnable과 Thread를 동기화된 클래스와 메서드를 이용해 잠갔다.
2. 자바 5에서 스레드 실행과 태스크 제출을 분리하는 ExecutorService, Runnable과 Thread의 변형을 반환하는 Callable<T>와 Future<T>, 제네릭 등을 지원한다.
3. 자바 7에서 분할-정복 알고리즘의 포크/조인 구현을 지원하는 RecursiveTask가 추가되었다.
4. 자바 8에서 스트림과 람다 지원에 기반한 병렬 프로세싱이 추가되었으며, Future를 조합하는 CompletableFuture를 지원한다.
5. 자바 9에서 분산 비동기 프로그래밍으로 발행-구독 프로토콜(Pub-Sub)을 지원한다.

## 스레드와 추상화
```java
sum = Arrays.stream(stats).parallel().sum();
```
7장에서 자바 스트림으로 외부 반복(명시적 루프) 대신 내부 반복을 통해 병렬성을 쉽게 달성할 수 있었다. 병렬 스트림 반복은 명시적으로 스레드를 사용하는 것에 비해 높은 수준의 개념이라는 사실을 알 수 있다. 다시 말해 스트림을 이용해 스레드 사용 패턴을 추상화할 수 있다.

## Executor와 스레드풀
자바 스레드는 직접 운영체제 스레드에 접근한다. 운영체제 스레드를 만들고 종료하려면 비싼 비용을 치러야 하며 운영체제 스레드의 숫자는 제한되어 있다. 따라서 기존 스레드가 실행되는 상태에서 계속 새로운 스레드를 만드는 상황이 일어나지 않도록 주의해야 한다.  

자바 ExecutorService는 태스크를 제출하고 나중에 결과를 수집할 수 있는 인터페이스를 제공한다. 프로그램은 ExecutorService의 newFixedThreadPool 같은 팩토리 메서드를 이용해 스레드 풀을 만들어 사용할 수 있다. 이 메서드는 워커 스레드라 불리는 nThreads를 가지는 ExecutorService를 만들고 워커 스레드들을 스레드 풀에 저장한다. 프로그래머가 태스크(Runnable이나 Callable)를 제공하면 스레드가 이를 실행한다.  

스레드를 직접 사용하는 것보다 스레드 풀을 이용하는 것이 바람직하지만 두 가지 사항을 주의해야 한다.
1. k 스레드를 가진 스레드 풀은 오직 k만큼의 스레드를 동시에 실행할 수 있다. 초과로 제출된 태스크는 큐에 저장되며 이전 태스크 중 하나가 종료되기 전까지는 스레드에 할당하되지 않는다. 만약 잠을 자거나 I/O를 기다리거나 네트워크 연결을 기다리는 태스크가 있다면 주의해야 한다. 자는 태스크는 스레드 풀의 병렬 실행 성능을 저하시킨다. I/O를 기다리는 블록 상황에서 이들 태스크가 워커 스레드에 할당된 상태를 유지하지만 아무 작업도 하지 않기 때문이다. 블록할 수 있는 태스크는 스레드 풀에 제출하지 않는 것이 좋다.
2. 중요한 코드를 실행하는 스레드가 죽는 일이 발생하지 않도록 보통 자바 프로그램은 main이 반환하기 전에 모든 스레드의 태스크가 끝나길 기다린다. 따라서 프로그램을 종료하기 전에 모든 프레드 풀을 종료하는 습관을 갖는 것이 중요하다. 

## 잠자기와 블로킹
어떤 일이 일정 속도로 제한되어 일어나는 상황의 애플리케이션을 만들 때 자연스럽게 sleep() 메서드를 사용할 수 있다. 하지만 스레드는 잠들어도 여전히 시스템 자원을 점유한다. 스레드가 많아지고 그 중 대부분이 잠을 잔다면 문제가 심각해진다. 스레드 풀에서 잠을 자는 태스크는 다른 태스크가 시작되지 못하게 막으므로 자원을 소비한다.  

블록 동작도 마찬가지다. 블록 동작은 다른 태스크가 어떤 동작을 완료하기를 기다리는 동작과 외부 상호작용을 기다리는 동작으로 구분할 수 있다.  

## 발행-구독 모델
자바 9에서는 java.util.concurrent.Flow의 인터페이스에 발행-구독 모델(pub-sub)을 적용해 리액티브 프로그래밍을 제공한다.
- 구독자(sub)가 구독할 수 있는 발행자(pub)
- 이 연결을 구독(subscription)이라 한다.
- 이 연결을 이용해 메시지(이벤트)를 전송한다.

여러 컴포넌트가 한 구독자로 구독할 수 있고 한 컴포넌트는 여러 개별 스트림을 발행할 수 있으며 한 컴포넌트는 여러 구독자에 가입할 수 있다.

## 업스트림과 다운스트림
컴퓨터 네트워크의 용어에서 업스트림(upstream)이란 로컬 기기에서 서버로 전송되는 데이터 흐름을 말하고, 다운스트림(downstream)이란 서버에서 로컬 기기로 전송되는 데이터 흐름을 말한다. 

## 리액티브 시스템 vs 리액티브 프로그래밍
리액티브 시스템과 리액티브 프로그래밍은 서로 상당히 다른 의미를 가지고 있다. 리액티브 시스템(reactive system)은 런타임 환경이 변화에 대응하도록 전체 아키텍처가 설계된 프로그램을 가리킨다. 리액티브 시스템이 가져야 할 공식적인 속성은 Reactive Manifesto에서 확인할 수 있다.

- 반응성(responsive) : 실시간으로 입력에 반응하는 것
- 회복성(resilient) : 한 컴포넌트의 실패로 전체 시스템이 실패하지 않는 것
- 탄력성(elastic) : 시스템이 자신의 작업 부하에 맞게 적응하며 작업을 효율적으로 처리하는 것

여러 가지 방법으로 리액티브 시스템을 구현할 수 있지만 java.util.concurrent.Flow와 관련된 인터페이스에서 제공하는 리액티브 프로그래밍 형식을 이용할 수도 있다. 